from collections import defaultdict
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import pandas as pd

from bids2table.handlers import Handler


@dataclass
class Record:
    metadata: Optional[Dict[str, Any]]
    data: Dict[str, Any]

    def key(self) -> str:
        if self.metadata is None:
            raise RuntimeError("metadata is required to generate a record key")
        return "_".join(f"{k}-{v}" for k, v in self.metadata.items())

    def flatten(self) -> Dict[str, Any]:
        flat_record = self.data.copy().update(self.metadata)
        return flat_record


# TODO: Is it a bit of an awkward dependency on the handlers here? I use them to
# determine the group order, and to fill in the missing "cells".
#
# This speaks to the dual purpose that handlers play in this design:
#   1) they handle files
#   2) they define the schema
# Is this a feature or a bug? Let's say it's a feature for now. I think it helps to
# co-locate these pieces of logic. A more general name might be appropriate though.
class GroupedRecordTable:
    def __init__(self, handlers: List[Handler]):
        self.handlers = handlers
        self._table: Dict[str, Dict[str, Record]] = defaultdict(dict)

    def add(self, record: Record, handler: Handler):
        """
        Add a record that was generated by the given handler. The record will be
        inserted into the handler's corresponding column group.
        """
        self._table[record.key()][handler.name] = record

    def fill(self):
        """
        Fill in missing column groups for each row.
        """
        for row in self._table.values():
            for handler in self.handlers:
                if handler.name not in row:
                    row[handler.name] = Record(None, handler.null_record())

    def flatten(self) -> Dict[str, Record]:
        """
        Merge the records in each row into a single record, flattening the column
        groups.
        """
        flat_records = {}
        for k, row in self._table.items():
            flat_metadata = None
            flat_data = {}
            # TODO: this flattens in the insertion order; not the handler order!
            #   - fixed
            for handler in self.handlers:
                if handler.name in row:
                    record = row[handler.name]
                    if record.metadata is not None:
                        if flat_metadata is None:
                            flat_metadata = record.metadata
                        elif record.metadata != flat_metadata:
                            raise RuntimeError(
                                "Metadata hashing failed; not all records in a group "
                                "contain the same metadata"
                            )
                    if not set(record.data.keys()).isdisjoint(flat_data.keys()):
                        raise RuntimeError(
                            "A record group contains repeated data columns"
                        )
                    flat_data.update(record.data)
            flat_records[k] = Record(flat_metadata, flat_data)
        return flat_records

    def to_pandas(self, key_index: bool = False) -> pd.DataFrame:
        """
        Convert the record table to a pandas ``DataFrame``. If ``key_index`` is
        ``True``, the record keys are used as the ``DataFrame`` index. Otherwise the
        default index is used.
        """
        self.fill()
        records = self.flatten()
        records = {k: record.flatten() for k, record in records.items()}
        if key_index:
            table = pd.DataFrame.from_dict(records, orient="index")
        else:
            table = pd.DataFrame.from_records(list(records.values()))
        return table
